/*
 * Copyright (C) 2022 CNPEM (cnpem.br)
 * Author: Ã‰rico Nogueira <erico.rolim@lnls.br>
 *
 * Released according to the GNU GPL, version 3 or any later version.
 */

#ifndef DECODERS_H
#define DECODERS_H

#include <cstdint>
#include <cstdio>
#include <optional>
#include <string_view>
#include <unordered_map>
#include <variant>
#include <vector>

#include <sys/types.h>

#include "sdb-defs.h"

#define LNLS_VENDORID 0x1000000000001215

class Printer;

template<uint64_t t_vendor_id, uint32_t t_device_id, uint8_t major_version>
bool device_match_impl(const struct sdb_device_info &devinfo)
{
    return (devinfo.vendor_id == t_vendor_id) && (devinfo.device_id == t_device_id) &&
      (devinfo.abi_ver_major == major_version);
}

class RegisterDecoder {
    bool is_boolean_value(const char *) const;
    int32_t try_boolean_value(const char *, int32_t) const;

    template <class T>
    void add_general_internal(const char *, T, bool);
    template <class T>
    void add_channel_internal(const char *, unsigned, T, bool);

  protected:
    size_t read_size;
    void *read_dest;

    struct pcie_bars &bars;
    struct sdb_device_info devinfo;

    /* hold data generated by the decoder;
     * - general is for the normal registers
     * - channel is for registers that are repeated for each channel
     *
     * int32_t is so far a generic enough value to be used here,
     * but int64_t can be considered if it ever becomes an issue.
     * we use double for floating point values */
    using data_type = std::variant<std::int32_t, double>;
    std::unordered_map<std::string_view, data_type> general_data;
    std::unordered_map<std::string_view, std::vector<data_type>> channel_data;
    /* hold the order in which the data has been added to the maps,
     * which allows us to implement printing cleanly and prettily
     * while also using an unordered_map */
    std::vector<const char *> general_data_order;
    std::vector<const char *> channel_data_order;
    /* flag to indicate that the vectors have been populated:
     * it should only happen once, and is cheaper than checking
     * for membership of strings */
    bool data_order_done = false;

    /* a device that has multiple channels will set this */
    std::optional<unsigned> number_of_channels;

    std::unordered_map<std::string_view, Printer> printers;

    RegisterDecoder(struct pcie_bars &, std::unordered_map<std::string_view, Printer>);
    virtual void decode() = 0;

    void add_general(const char *, int32_t, bool = false);
    void add_general_double(const char *, double, bool = false);
    void add_channel_impl(const char *, unsigned, int32_t, bool = false);
    void add_channel_impl_double(const char *, unsigned, double, bool = false);

  public:
    virtual ~RegisterDecoder();
    virtual void read();
    void binary_dump(FILE *) const;
    virtual void print(FILE *, bool) const;

    void set_devinfo(const struct sdb_device_info &);

    template <class T>
    T get_general_data(const char *) const;
    template <class T>
    T get_channel_data(const char *, unsigned) const;

    device_match_fn device_match;

    std::optional<unsigned> channel;
};

#endif
